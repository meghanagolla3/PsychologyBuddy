// src/middlewares/permission.middleware.ts

import { NextRequest, NextResponse } from "next/server";
import { AuthRepository } from "@/src/server/repository/auth.repository";
import { ROLE_PERMISSIONS, MODULES, ACTIONS } from "@/src/config/permission";

interface PermissionOptions {
  module: keyof typeof MODULES;
  action?: keyof typeof ACTIONS; // optional â€” defaults to "view"
}

/**
 * Middleware-style wrapper for API routes
 * 
 * Usage:
 *   export const POST = withPermission({ module: 'PSYCHO_EDUCATION', action: 'CREATE' })(handler)
 */
export function withPermission(options: PermissionOptions) {
  const { module, action = "VIEW" } = options;
  const requiredPermissionKey = `${MODULES[module]}.${ACTIONS[action]}`;

  return function <T extends (...args: any[]) => any>(handler: T) {
    return async function (req: NextRequest, ctx: any) {
      // Step 1: Get session from cookie
      const sessionId = req.cookies.get('sessionId')?.value || 
                      req.headers.get('authorization')?.replace('Bearer ', '');

      if (!sessionId) {
        return NextResponse.json(
          { success: false, message: "Not authenticated" },
          { status: 401 }
        );
      }

      // Step 2: Find session and user with permissions
      const session = await AuthRepository.findSessionBySessionId(sessionId);
      
      if (!session) {
        return NextResponse.json(
          { success: false, message: "Invalid session" },
          { status: 401 }
        );
      }

      // Step 3: Check if session is expired
      if (session.expiresAt < new Date()) {
        await AuthRepository.deleteSession(sessionId);
        return NextResponse.json(
          { success: false, message: "Session expired" },
          { status: 401 }
        );
      }

      const user = session.user;

      // Extract schoolId from user's school relation
      const userSchoolId = user.school?.id || user.schoolId;

      // For non-SUPERADMIN users, schoolId is required
      if (user.role.name !== "SUPERADMIN" && !userSchoolId) {
        return NextResponse.json(
          { success: false, message: "User is not assigned to any school" },
          { status: 403 }
        );
      }

      // Step 4: SuperAdmin always bypasses permission checks
      if (user.role.name === "SUPERADMIN") {
        return handler(req, { ...ctx, user, userSchoolId });
      }

      // Step 5: Get user permissions from role
      const userPermissions = ROLE_PERMISSIONS[user.role.name as keyof typeof ROLE_PERMISSIONS] || [];

      // Step 6: Check if user has required permission
      const hasPermission = userPermissions.includes(requiredPermissionKey as any);

      if (!hasPermission) {
        return NextResponse.json(
          {
            success: false,
            message: `Forbidden: Missing permission '${requiredPermissionKey}'`,
            requiredPermission: requiredPermissionKey,
            userRole: user.role.name,
          },
          { status: 403 }
        );
      }

      // Step 7: School/organization scoping for admins
      if (user.role.name === "ADMIN" && userSchoolId) {
        // Admin can only access resources from their school
        // This will be implemented in specific API routes
        ctx.userSchoolId = userSchoolId;
      }

      // Step 8: Pass user into API handler context
      return handler(req, { ...ctx, user, userSchoolId });
    };
  };
}
