import React, { useState } from "react";
import { BookOpen, Music, Sparkles } from "lucide-react";
import { AdminHeader } from "@/src/components/admin/layout/AdminHeader";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import JournalingTools from "./SelfHelpTools/JournalingTools";
import MusicTools from "./SelfHelpTools/MusicTools";
import MeditationTools from "./SelfHelpTools/MeditationTools";

export default function SelfHelpTools() {
  const [activeTab, setActiveTab] = useState("journaling");
  const [searchQuery, setSearchQuery] = useState("");

  const renderActions = () => {
    // Actions are now handled by individual components
    return null;
  };

  return (
    <div className="flex flex-col min-h-screen">
      <AdminHeader 
        title="Self-help Tools" 
        subtitle="Manage interactive wellness tools for learners"
        showTimeFilter={false}
        actions={renderActions()}
      />
      
      <div className="flex-1 overflow-auto p-6 space-y-6 animate-fade-in">
        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
          <TabsList className="grid w-full max-w-md grid-cols-3">
            <TabsTrigger value="journaling" className="gap-2">
              <BookOpen className="h-4 w-4" />
              Journaling
            </TabsTrigger>
            <TabsTrigger value="music" className="gap-2">
              <Music className="h-4 w-4" />
              Music Therapy
            </TabsTrigger>
            <TabsTrigger value="meditation" className="gap-2">
              <Sparkles className="h-4 w-4" />
              Meditation
            </TabsTrigger>
          </TabsList>

          {/* Journaling Tab */}
          <TabsContent value="journaling">
            <JournalingTools searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
          </TabsContent>

          {/* Music Therapy Tab */}
          <TabsContent value="music">
            <MusicTools searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
          </TabsContent>

          {/* Meditation Tab */}
          <TabsContent value="meditation">
            <MeditationTools searchQuery={searchQuery} setSearchQuery={setSearchQuery} />
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}

  
  
  
  const fetchMeditationGoals = async () => {
    try {
      const response = await fetch('/api/admin/meditation/goals');
      const data: ApiResponse<any[]> = await response.json();
      if (data.success && data.data) {
        const goalNames = data.data.map((goal: any) => goal.name);
        const goalMap: {[key: string]: string} = {};
        data.data.forEach((goal: any) => {
          goalMap[goal.name] = goal.id;
        });
        setMeditationGoals(goalNames);
        setMeditationGoalsMap(goalMap);
      }
    } catch (error) {
      console.error('Failed to fetch meditation goals:', error);
      toast({ title: "Error", description: "Failed to fetch meditation goals", variant: "destructive" });
    }
  };

  const fetchMeditationCategories = async () => {
    try {
      const response = await fetch('/api/admin/meditation/categories');
      const data: ApiResponse<any[]> = await response.json();
      if (data.success && data.data) {
        const categoryNames = data.data.map((category: any) => category.name);
        const categoryMap: {[key: string]: string} = {};
        data.data.forEach((category: any) => {
          categoryMap[category.name] = category.id;
        });
        setMeditationCategories(categoryNames);
        setMeditationCategoriesMap(categoryMap);
      }
    } catch (error) {
      console.error('Failed to fetch meditation categories:', error);
      toast({ title: "Error", description: "Failed to fetch meditation categories", variant: "destructive" });
    }
  };

  const fetchMusicCategories = async () => {
    try {
      const response = await fetch('/api/admin/music/categories');
      const data: ApiResponse<any[]> = await response.json();
      if (data.success && data.data) {
        const categoryNames = data.data.map((category: any) => category.name);
        const categoryMap: {[key: string]: string} = {};
        data.data.forEach((category: any) => {
          categoryMap[category.name] = category.id;
        });
        setMusicCategories(categoryNames);
        setMusicCategoriesMap(categoryMap);
      }
    } catch (error) {
      console.error('Failed to fetch music categories:', error);
      toast({ title: "Error", description: "Failed to fetch music categories", variant: "destructive" });
    }
  };

  const fetchGoals = async () => {
    try {
      const response = await fetch('/api/labels/goals');
      const data: ApiResponse<any[]> = await response.json();
      if (data.success && data.data) {
        const goalNames = data.data.map((goal: any) => goal.name);
        const goalMap: {[key: string]: string} = {};
        data.data.forEach((goal: any) => {
          goalMap[goal.name] = goal.id;
        });
        setMusicGoals(goalNames);
        setMusicGoalsMap(goalMap);
      }
    } catch (error) {
      console.error('Failed to fetch goals:', error);
      toast({ title: "Error", description: "Failed to fetch goals", variant: "destructive" });
    }
  };

  const fetchMusicResources = async () => {
    try {
      const response = await fetch('/api/admin/music/resources?page=1&limit=20');
      const data: PaginatedResponse<MusicResource> = await response.json();
      if (data.success && data.data?.resources) {
        setMusicResources(data.data.resources);
      }
    } catch (error) {
      console.error('Failed to fetch music resources:', error);
      toast({ title: "Error", description: "Failed to fetch music resources", variant: "destructive" });
    }
  };

  const fetchMeditationResources = async () => {
    try {
      const response = await fetch('/api/admin/meditation/resources?page=1&limit=20');
      const data: PaginatedResponse<MeditationResource> = await response.json();
      if (data.success && data.data?.resources) {
        setMeditationResources(data.data.resources);
      }
    } catch (error) {
      console.error('Failed to fetch meditation resources:', error);
      toast({ title: "Error", description: "Failed to fetch meditation resources", variant: "destructive" });
    }
  };

  const createJournalPrompt = async () => {
    setIsSubmitting(true);
    try {
      const response = await fetch('/api/admin/journaling/prompts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: journalForm.prompt,
          moods: journalForm.moods,
          journalTypes: journalForm.journalTypes,
          isEnabled: true
        })
      });
      const data: ApiResponse<JournalPrompt> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: "Journal prompt created successfully" });
        setJournalForm({ prompt: "", moods: [], journalTypes: ["writing"] });
        setIsAddJournalOpen(false);
        await fetchJournalPrompts();
      } else {
        toast({ title: "Error", description: data.error || "Failed to create prompt", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to create journal prompt:', error);
      toast({ title: "Error", description: "Failed to create journal prompt", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  const updateMusicResourceStatus = async (id: string, status: 'PUBLISHED' | 'DRAFT') => {
    try {
      const response = await fetch(`/api/admin/music/resources?id=${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, status })
      });
      const data: ApiResponse<MusicResource> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: `Music resource ${status.toLowerCase()} successfully` });
        await fetchMusicResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to update resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to update music resource:', error);
      toast({ title: "Error", description: "Failed to update music resource", variant: "destructive" });
    }
  };

  const deleteMusicResource = async (id: string) => {
    try {
      const response = await fetch(`/api/admin/music/resources?id=${id}`, {
        method: 'DELETE'
      });
      const data: ApiResponse<null> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: "Music resource deleted successfully" });
        await fetchMusicResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to delete resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to delete music resource:', error);
      toast({ title: "Error", description: "Failed to delete music resource", variant: "destructive" });
    }
  };

  const updateMeditationResourceStatus = async (id: string, status: 'PUBLISHED' | 'DRAFT') => {
    try {
      const response = await fetch(`/api/admin/meditation/resources?id=${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, status })
      });
      const data: ApiResponse<MeditationResource> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: `Meditation resource ${status.toLowerCase()} successfully` });
        await fetchMeditationResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to update resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to update meditation resource:', error);
      toast({ title: "Error", description: "Failed to update meditation resource", variant: "destructive" });
    }
  };

  const deleteMeditationResource = async (id: string) => {
    try {
      const response = await fetch(`/api/admin/meditation/resources?id=${id}`, {
        method: 'DELETE'
      });
      const data: ApiResponse<null> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: "Meditation resource deleted successfully" });
        await fetchMeditationResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to delete resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to delete meditation resource:', error);
      toast({ title: "Error", description: "Failed to delete meditation resource", variant: "destructive" });
    }
  };

  const createMusicResource = async () => {
    setIsSubmitting(true);
    try {
      // Convert duration string to number if provided
      const durationInSeconds = musicForm.duration ? parseDurationToSeconds(musicForm.duration) : undefined;
      
      // Validate URL - if it's a blob URL, we need to handle it differently
      const audioUrl = musicForm.audioUrl || musicForm.url;
      if (!audioUrl) {
        toast({ title: "Error", description: "Please upload an audio file", variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      
      // Validate required fields
      if (!musicForm.title.trim()) {
        toast({ title: "Error", description: "Title is required", variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      
      // For now, use a placeholder URL for blob URLs since the schema requires a valid URL
      // In a real implementation, you'd upload the file to a storage service first
      const finalUrl = audioUrl.startsWith('blob:') ? 'https://placeholder.audio/file.mp3' : audioUrl;
      
      const payload: any = {
        title: musicForm.title,
        url: finalUrl,
        isPublic: musicForm.isPublic,
        status: musicForm.status,
      };
      
      // Only add optional fields if they have values
      if (musicForm.description?.trim()) payload.description = musicForm.description;
      if (durationInSeconds !== undefined) payload.duration = durationInSeconds;
      if (musicForm.artist?.trim()) payload.artist = musicForm.artist;
      if (musicForm.album?.trim()) payload.album = musicForm.album;
      if (musicForm.coverImage?.trim()) payload.coverImage = musicForm.coverImage;
      if (musicForm.category && musicCategoriesMap[musicForm.category]) {
        payload.categoryIds = [musicCategoriesMap[musicForm.category]];
      }
      if (musicForm.goal && musicGoalsMap[musicForm.goal]) {
        payload.goalIds = [musicGoalsMap[musicForm.goal]];
      }

      console.log('Sending payload:', JSON.stringify(payload, null, 2)); // Debug log

      const response = await fetch('/api/admin/music/resources', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data: ApiResponse<MusicResource> = await response.json();
      
      if (!response.ok) {
        console.error('API Error Response:', data);
        console.error('Status:', response.status);
        console.error('Status Text:', response.statusText);
      }
      
      if (data.success) {
        toast({ title: "Success", description: "Music resource created successfully" });
        setMusicForm({
          title: "",
          subtitle: "",
          description: "",
          url: "",
          audioUrl: "",
          duration: "",
          artist: "",
          album: "",
          coverImage: "",
          thumbnail: "",
          isPublic: true,
          status: "DRAFT",
          category: "",
          supportedMoods: [],
          goal: ""
        });
        setIsAddMusicModalOpen(false);
        await fetchMusicResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to create music resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to create music resource:', error);
      toast({ title: "Error", description: "Failed to create music resource", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  const createMeditationResource = async () => {
    setIsSubmitting(true);
    try {
      // Validate required fields
      if (!meditationForm.title.trim()) {
        toast({ title: "Error", description: "Title is required", variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      
      if (!meditationForm.description.trim()) {
        toast({ title: "Error", description: "Description is required", variant: "destructive" });
        setIsSubmitting(false);
        return;
      }

      // Validate URL based on format
      const mediaUrl = meditationForm.format === "AUDIO" ? meditationForm.audioUrl : meditationForm.videoUrl;
      if (meditationForm.format !== "TEXT" && !mediaUrl) {
        toast({ title: "Error", description: `Please upload a ${meditationForm.format.toLowerCase()} file`, variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      
      const payload: any = {
        title: meditationForm.title,
        description: meditationForm.description,
        format: meditationForm.format,
        type: meditationForm.type,
        status: meditationForm.status,
      };
      
      // Only add optional fields if they have values
      if (meditationForm.thumbnailUrl?.trim()) payload.thumbnailUrl = meditationForm.thumbnailUrl;
      if (meditationForm.durationSec && parseInt(meditationForm.durationSec) > 0) {
        payload.durationSec = parseInt(meditationForm.durationSec);
      }
      if (meditationForm.instructor?.trim()) payload.instructor = meditationForm.instructor;
      if (meditationForm.format === "AUDIO" && mediaUrl) payload.audioUrl = mediaUrl;
      if (meditationForm.format === "VIDEO" && mediaUrl) payload.videoUrl = mediaUrl;
      if (meditationForm.category && meditationCategoriesMap[meditationForm.category]) {
        payload.categoryIds = [meditationCategoriesMap[meditationForm.category]];
      }
      if (meditationForm.goal && meditationGoalsMap[meditationForm.goal]) {
        payload.goalIds = [meditationGoalsMap[meditationForm.goal]];
      }
      if (meditationForm.mood && meditationMoodsMap[meditationForm.mood]) {
        payload.moodIds = [meditationMoodsMap[meditationForm.mood]];
      }

      console.log('Sending meditation payload:', JSON.stringify(payload, null, 2));

      const response = await fetch('/api/admin/meditation/resources', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data: ApiResponse<MeditationResource> = await response.json();
      
      if (!response.ok) {
        console.error('API Error Response:', data);
        console.error('Status:', response.status);
        console.error('Status Text:', response.statusText);
      }
      
      if (data.success) {
        toast({ title: "Success", description: "Meditation resource created successfully" });
        setMeditationForm({
          title: "",
          description: "",
          thumbnailUrl: "",
          format: "AUDIO",
          audioUrl: "",
          videoUrl: "",
          durationSec: "",
          instructor: "",
          type: "GUIDED",
          status: "DRAFT",
          category: "",
          goal: "",
          mood: ""
        });
        setIsAddMeditationModalOpen(false);
        await fetchMeditationResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to create meditation resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to create meditation resource:', error);
      toast({ title: "Error", description: "Failed to create meditation resource", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  const createMusicCategory = async () => {
    setIsSubmitting(true);
    try {
      const response = await fetch('/api/admin/music/categories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(categoryForm)
      });
      const data: ApiResponse<any> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: "Music category created successfully" });
        setCategoryForm({
          name: "",
          description: "",
          icon: "",
          color: "#3B82F6",
          status: "ACTIVE"
        });
        setIsAddCategoryModalOpen(false);
      } else {
        toast({ title: "Error", description: data.error || "Failed to create category", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to create music category:', error);
      toast({ title: "Error", description: "Failed to create music category", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  const createMeditationCategory = async () => {
    setIsSubmitting(true);
    try {
      const response = await fetch('/api/admin/meditation/categories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(categoryForm)
      });
      const data: ApiResponse<any> = await response.json();
      if (data.success) {
        toast({ title: "Success", description: "Meditation category created successfully" });
        setCategoryForm({
          name: "",
          description: "",
          icon: "",
          color: "#3B82F6",
          status: "ACTIVE"
        });
        setIsAddMeditationCategoryModalOpen(false);
        await fetchMeditationCategories();
      } else {
        toast({ title: "Error", description: data.error || "Failed to create meditation category", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to create meditation category:', error);
      toast({ title: "Error", description: "Failed to create meditation category", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  const parseDurationToSeconds = (duration: string): number => {
    const parts = duration.split(':');
    if (parts.length === 2) {
      return parseInt(parts[0]) * 60 + parseInt(parts[1]);
    }
    return parseInt(duration) || 0;
  };

  const handleThumbnailUpload = (e: React.ChangeEvent<HTMLInputElement>, type: string) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = (event) => {
        const result = event.target?.result as string;
        if (result && type === "music") {
          setMusicForm(prev => ({ ...prev, thumbnail: result }));
          toast({ title: "Thumbnail Uploaded", description: "Thumbnail image uploaded successfully" });
        }
      };
      reader.readAsDataURL(file);
    }
  };

  const handleAudioUpload = (e: React.ChangeEvent<HTMLInputElement>, type: string) => {
    const file = e.target.files?.[0];
    if (file) {
      // Create object URL for audio preview and storage
      const audioUrl = URL.createObjectURL(file);
      
      // Calculate duration (for now, use a default or estimate)
      const audio = new Audio();
      audio.src = audioUrl;
      
      audio.addEventListener('loadedmetadata', () => {
        const duration = Math.floor(audio.duration);
        const minutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        setMusicForm(prev => ({ 
          ...prev, 
          audioUrl: audioUrl,
          duration: `${minutes}:${seconds.toString().padStart(2, '0')}`
        }));
      });
      
      toast({ title: "Audio Uploaded", description: `Audio file "${file.name}" uploaded successfully` });
    }
  };

  const handleMeditationThumbnailUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = (event) => {
        const result = event.target?.result as string;
        if (result) {
          setMeditationForm(prev => ({ ...prev, thumbnailUrl: result }));
          toast({ title: "Thumbnail Uploaded", description: "Thumbnail image uploaded successfully" });
        }
      };
      reader.readAsDataURL(file);
    }
  };

  const handleMeditationAudioUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const audioUrl = URL.createObjectURL(file);
      
      const audio = new Audio();
      audio.src = audioUrl;
      
      audio.addEventListener('loadedmetadata', () => {
        const duration = Math.floor(audio.duration);
        setMeditationForm(prev => ({ 
          ...prev, 
          audioUrl: audioUrl,
          durationSec: duration.toString()
        }));
      });
      
      toast({ title: "Audio Uploaded", description: `Audio file "${file.name}" uploaded successfully` });
    }
  };

  const handleMeditationVideoUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const videoUrl = URL.createObjectURL(file);
      
      const video = document.createElement('video');
      video.src = videoUrl;
      
      video.addEventListener('loadedmetadata', () => {
        const duration = Math.floor(video.duration);
        setMeditationForm(prev => ({ 
          ...prev, 
          videoUrl: videoUrl,
          durationSec: duration.toString()
        }));
      });
      
      toast({ title: "Video Uploaded", description: `Video file "${file.name}" uploaded successfully` });
    }
  };

  // Load data on component mount
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      await Promise.all([
        fetchJournalPrompts(),
        fetchMusicResources(),
        fetchMeditationResources(),
        fetchMoods(),
        fetchGoals(),
        fetchJournalMoods(),
        fetchMeditationMoods(),
        fetchMeditationGoals(),
        fetchMeditationCategories(),
        fetchMusicCategories()
      ]);
      setIsLoading(false);
    };
    loadData();
  }, []);

  const renderActions = () => {
    if (activeTab === "journaling") {
      return (
        <Button onClick={() => setIsAddJournalOpen(true)} className="gap-2">
          <Plus className="h-4 w-4" />
          Add Prompt
        </Button>
      );
    } else if (activeTab === "music") {
      return (
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => setIsAddCategoryModalOpen(true)} className="gap-2">
            <Plus className="h-4 w-4" />
            Add Category
          </Button>
          <Button onClick={() => setIsAddMusicModalOpen(true)} className="gap-2">
            <Plus className="h-4 w-4" />
            Add Resources
          </Button>
        </div>
      );
    } else if (activeTab === "meditation") {
      return (
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => setIsAddMeditationCategoryModalOpen(true)} className="gap-2">
            <Plus className="h-4 w-4" />
            Add Category
          </Button>
          <Button onClick={() => setIsAddMeditationModalOpen(true)} className="gap-2">
            <Plus className="h-4 w-4" />
            Add Meditation
          </Button>
        </div>
      );
    }
    return null;
  };

  // Handlers
  const handleToggleConfirm = (type: string, id: string, currentEnabled: boolean) => {
    setConfirmAction({ type, id, action: currentEnabled ? "deactivate" : "activate" });
    setIsConfirmOpen(true);
  };

  const handleConfirmToggle = async () => {
    if (confirmAction) {
      if (confirmAction.type === "music") {
        await updateMusicResourceStatus(confirmAction.id, confirmAction.action === "activate" ? "PUBLISHED" : "DRAFT");
      } else if (confirmAction.type === "meditation") {
        await updateMeditationResourceStatus(confirmAction.id, confirmAction.action === "activate" ? "PUBLISHED" : "DRAFT");
      } else {
        toast({
          title: confirmAction.action === "activate" ? "Resource Activated" : "Resource Deactivated",
          description: `The resource has been ${confirmAction.action}d successfully.`,
        });
      }
    }
    setIsConfirmOpen(false);
    setConfirmAction(null);
  };

  const handleJournalingConfigChange = (key: keyof JournalingConfig, value: boolean) => {
    setJournalingConfig((prev: JournalingConfig) => ({ ...prev, [key]: value }));
    toast({
      title: value ? "Enabled" : "Disabled",
      description: `${key.replace("Enabled", "")} journaling has been ${value ? "enabled" : "disabled"} for students.`,
    });
  };

  const handleAudioConfigChange = <K extends keyof AudioJournalingConfig>(key: K, value: AudioJournalingConfig[K]) => {
    setAudioConfig((prev: AudioJournalingConfig) => ({ ...prev, [key]: value }));
    toast({ title: "Settings Updated", description: "Audio journaling configuration has been saved." });
  };

  const handleArtConfigChange = (key: keyof ArtJournalingConfig, value: boolean) => {
    setArtConfig((prev: ArtJournalingConfig) => ({ ...prev, [key]: value }));
    toast({ title: "Settings Updated", description: "Art journaling configuration has been saved." });
  };

  const handleSaveJournal = async () => {
    await createJournalPrompt();
  };

  const handleSaveMusic = async () => {
    setIsSubmitting(true);
    try {
      // Convert duration string to number if provided
      const durationInSeconds = musicForm.duration ? parseDurationToSeconds(musicForm.duration) : undefined;
      
      // Validate URL - if it's a blob URL, we need to handle it differently
      const audioUrl = musicForm.audioUrl || musicForm.url;
      if (!audioUrl) {
        toast({ title: "Error", description: "Please upload an audio file", variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      
      // Validate required fields
      if (!musicForm.title.trim()) {
        toast({ title: "Error", description: "Title is required", variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      
      // For now, use a placeholder URL for blob URLs since the schema requires a valid URL
      // In a real implementation, you'd upload the file to a storage service first
      const finalUrl = audioUrl.startsWith('blob:') ? 'https://placeholder.audio/file.mp3' : audioUrl;
      
      const payload: any = {
        title: musicForm.title,
        url: finalUrl,
        isPublic: musicForm.isPublic,
        status: musicForm.status,
      };
      
      // Only add optional fields if they have values
      if (musicForm.description?.trim()) payload.description = musicForm.description;
      if (durationInSeconds !== undefined) payload.duration = durationInSeconds;
      if (musicForm.artist?.trim()) payload.artist = musicForm.artist;
      if (musicForm.album?.trim()) payload.album = musicForm.album;
      if (musicForm.coverImage?.trim()) payload.coverImage = musicForm.coverImage;
      if (musicForm.category && musicCategoriesMap[musicForm.category]) {
        payload.categoryIds = [musicCategoriesMap[musicForm.category]];
      }
      if (musicForm.goal && musicGoalsMap[musicForm.goal]) {
        payload.goalIds = [musicGoalsMap[musicForm.goal]];
      }

      console.log('Sending payload:', JSON.stringify(payload, null, 2)); // Debug log

      const response = await fetch('/api/admin/music/resources', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data: ApiResponse<MusicResource> = await response.json();
      
      if (!response.ok) {
        console.error('API Error Response:', data);
        console.error('Status:', response.status);
        console.error('Status Text:', response.statusText);
      }
      
      if (data.success) {
        toast({ title: "Success", description: "Music resource created successfully" });
        setMusicForm({
          title: "",
          subtitle: "",
          description: "",
          url: "",
          audioUrl: "",
          duration: "",
          artist: "",
          album: "",
          coverImage: "",
          thumbnail: "",
          isPublic: true,
          status: "DRAFT",
          category: "",
          supportedMoods: [],
          goal: ""
        });
        setIsAddMusicModalOpen(false);
        await fetchMusicResources();
      } else {
        toast({ title: "Error", description: data.error || "Failed to create music resource", variant: "destructive" });
      }
    } catch (error) {
      console.error('Failed to create music resource:', error);
      toast({ title: "Error", description: "Failed to create music resource", variant: "destructive" });
    } finally {
      setIsSubmitting(false);
    }
  };

  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getAutoDeleteLabel = (value: string) => {
    switch (value) {
      case "manual": return "Manual only";
      case "7days": return "After 7 days";
      case "14days": return "After 14 days";
      case "30days": return "After 30 days";
      case "90days": return "After 90 days";
      default: return "Manual only";
    }
  };

  const filteredPrompts = journalPrompts.filter(p => 
    p.prompt.toLowerCase().includes(searchQuery.toLowerCase()) ||
    p.moods.some(m => m.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  const filteredMusicResources = musicResources.filter(r => 
    r.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    r.categories?.some(c => c.category.name.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  const filteredMeditationResources = meditationResources.filter(r => 
    r.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    r.categories?.some(c => c.category.name.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  if (isLoading) {
    return (
      <div className="flex flex-col min-h-screen">
        <AdminHeader 
          title="Self-help Tools" 
          subtitle="Manage interactive wellness tools for learners"
          showTimeFilter={false}
        />
        <div className="flex-1 flex items-center justify-center">
          <div className="flex items-center gap-2">
            <Loader2 className="h-6 w-6 animate-spin" />
            <span>Loading self-help tools...</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen">
      <AdminHeader 
        title="Self-help Tools" 
        subtitle="Manage interactive wellness tools for learners"
        showTimeFilter={false}
        actions={renderActions()}
      />
      
      <div className="flex-1 overflow-auto p-6 space-y-6 animate-fade-in">
        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
          <TabsList className="grid w-full max-w-md grid-cols-3">
            <TabsTrigger value="journaling" className="gap-2">
              <BookOpen className="h-4 w-4" />
              Journaling
            </TabsTrigger>
            <TabsTrigger value="music" className="gap-2">
              <Music className="h-4 w-4" />
              Music Therapy
            </TabsTrigger>
            <TabsTrigger value="meditation" className="gap-2">
              <Sparkles className="h-4 w-4" />
              Meditation
            </TabsTrigger>
          </TabsList>

          {/* Journaling Tab */}
          <TabsContent value="journaling" className="space-y-6">
            {/* Privacy Notice */}
            <div className="flex items-start gap-3 rounded-lg bg-blue-50 dark:bg-blue-950/30 border border-blue-200 dark:border-blue-900 p-4">
              <Shield className="h-5 w-5 text-blue-600 dark:text-blue-400 mt-0.5 shrink-0" />
              <div>
                <p className="text-sm font-medium text-blue-900 dark:text-blue-100">Privacy Protected</p>
                <p className="text-sm text-blue-700 dark:text-blue-300">
                  Journaling content is private to students and is not accessible or reviewed by administrators.
                </p>
              </div>
            </div>

            {/* Journaling Types Configuration */}
            <Card>
              <CardHeader>
                <CardTitle className="text-base flex items-center gap-2">
                  <BookOpen className="h-5 w-5 text-primary" />
                  Journaling Types
                </CardTitle>
                <CardDescription>Enable or disable journaling modes for students</CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div className="flex items-center justify-between p-4 rounded-lg border border-border">
                    <div className="flex items-center gap-3">
                      <div className="h-10 w-10 rounded-lg bg-primary/10 flex items-center justify-center">
                        <PenTool className="h-5 w-5 text-primary" />
                      </div>
                      <div>
                        <p className="font-medium text-sm">Writing</p>
                        <p className="text-xs text-muted-foreground">Text-based journaling</p>
                      </div>
                    </div>
                    <Switch 
                      checked={journalingConfig.writingEnabled}
                      onCheckedChange={(v) => handleJournalingConfigChange("writingEnabled", v)}
                    />
                  </div>

                  <div className="flex items-center justify-between p-4 rounded-lg border border-border">
                    <div className="flex items-center gap-3">
                      <div className="h-10 w-10 rounded-lg bg-primary/10 flex items-center justify-center">
                        <Mic className="h-5 w-5 text-primary" />
                      </div>
                      <div>
                        <p className="font-medium text-sm">Audio</p>
                        <p className="text-xs text-muted-foreground">Voice recordings</p>
                      </div>
                    </div>
                    <Switch 
                      checked={journalingConfig.audioEnabled}
                      onCheckedChange={(v) => handleJournalingConfigChange("audioEnabled", v)}
                    />
                  </div>

                  <div className="flex items-center justify-between p-4 rounded-lg border border-border">
                    <div className="flex items-center gap-3">
                      <div className="h-10 w-10 rounded-lg bg-primary/10 flex items-center justify-center">
                        <Palette className="h-5 w-5 text-primary" />
                      </div>
                      <div>
                        <p className="font-medium text-sm">Art-Based</p>
                        <p className="text-xs text-muted-foreground">Drawing & visual art</p>
                      </div>
                    </div>
                    <Switch 
                      checked={journalingConfig.artEnabled}
                      onCheckedChange={(v) => handleJournalingConfigChange("artEnabled", v)}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Audio Journaling Configuration */}
            {journalingConfig.audioEnabled && (
              <Card>
                <CardHeader>
                  <CardTitle className="text-base flex items-center gap-2">
                    <Mic className="h-5 w-5 text-primary" />
                    Audio Journaling Settings
                  </CardTitle>
                  <CardDescription>Configure audio recording parameters (content is never accessible to admins)</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div className="space-y-2">
                      <Label className="flex items-center gap-2">
                        <Clock className="h-4 w-4 text-muted-foreground" />
                        Maximum Recording Duration
                      </Label>
                      <Select 
                        value={audioConfig.maxRecordingDuration.toString()} 
                        onValueChange={(v) => handleAudioConfigChange("maxRecordingDuration", parseInt(v))}
                      >
                        <SelectTrigger>
                          <SelectValue>{formatDuration(audioConfig.maxRecordingDuration)}</SelectValue>
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="60">1:00 (1 minute)</SelectItem>
                          <SelectItem value="120">2:00 (2 minutes)</SelectItem>
                          <SelectItem value="180">3:00 (3 minutes)</SelectItem>
                          <SelectItem value="300">5:00 (5 minutes)</SelectItem>
                          <SelectItem value="600">10:00 (10 minutes)</SelectItem>
                        </SelectContent>
                      </Select>
                      <p className="text-xs text-muted-foreground">Maximum length for each audio recording</p>
                    </div>

                    <div className="space-y-2">
                      <Label className="flex items-center gap-2">
                        <Trash className="h-4 w-4 text-muted-foreground" />
                        Auto-Delete Behavior
                      </Label>
                      <Select 
                        value={audioConfig.autoDeleteBehavior} 
                        onValueChange={(v: AudioJournalingConfig["autoDeleteBehavior"]) => handleAudioConfigChange("autoDeleteBehavior", v)}
                      >
                        <SelectTrigger>
                          <SelectValue>{getAutoDeleteLabel(audioConfig.autoDeleteBehavior)}</SelectValue>
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="manual">Manual only (student deletes)</SelectItem>
                          <SelectItem value="7days">Auto-delete after 7 days</SelectItem>
                          <SelectItem value="14days">Auto-delete after 14 days</SelectItem>
                          <SelectItem value="30days">Auto-delete after 30 days</SelectItem>
                          <SelectItem value="90days">Auto-delete after 90 days</SelectItem>
                        </SelectContent>
                      </Select>
                      <p className="text-xs text-muted-foreground">When audio recordings are automatically removed</p>
                    </div>
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Art Journaling Configuration */}
            {journalingConfig.artEnabled && (
              <Card>
                <CardHeader>
                  <CardTitle className="text-base flex items-center gap-2">
                    <Palette className="h-5 w-5 text-primary" />
                    Art Journaling Settings
                  </CardTitle>
                  <CardDescription>Configure canvas tools for art journaling (drawings are never visible to admins)</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <p className="text-sm text-muted-foreground">Enable or disable canvas tools globally</p>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <div className="flex items-center justify-between p-3 rounded-lg border border-border">
                        <div className="flex items-center gap-2">
                          <Undo className="h-4 w-4 text-muted-foreground" />
                          <span className="text-sm">Undo / Redo</span>
                        </div>
                        <Switch 
                          checked={artConfig.undoRedoEnabled}
                          onCheckedChange={(v) => handleArtConfigChange("undoRedoEnabled", v)}
                        />
                      </div>
                      <div className="flex items-center justify-between p-3 rounded-lg border border-border">
                        <div className="flex items-center gap-2">
                          <Palette className="h-4 w-4 text-muted-foreground" />
                          <span className="text-sm">Color Palette</span>
                        </div>
                        <Switch 
                          checked={artConfig.colorPaletteEnabled}
                          onCheckedChange={(v) => handleArtConfigChange("colorPaletteEnabled", v)}
                        />
                      </div>
                      <div className="flex items-center justify-between p-3 rounded-lg border border-border">
                        <div className="flex items-center gap-2">
                          <Trash2 className="h-4 w-4 text-muted-foreground" />
                          <span className="text-sm">Clear Canvas</span>
                        </div>
                        <Switch 
                          checked={artConfig.clearCanvasEnabled}
                          onCheckedChange={(v) => handleArtConfigChange("clearCanvasEnabled", v)}
                        />
                      </div>
                    </div>
                  </div>
                </CardContent>
              </Card>
            )}

            <Separator />

            {/* Mood-Based Prompts Section */}
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-lg font-semibold">Mood-Based Prompts</h3>
                  <p className="text-sm text-muted-foreground">
                    Manage prompts for writing and art journaling. Prompts can be reused across journaling types.
                  </p>
                </div>
              </div>
              {/* Search */}
              <div className="relative max-w-md">
                <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
                <Input 
                  placeholder="Search prompts..."
                  className="pl-9"
                  value={searchQuery}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
                />
              </div>

              {/* Prompts Grid */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {filteredPrompts.map((prompt) => (
                  <Card key={prompt.id} className={cn("transition-all duration-200", !prompt.isEnabled && "opacity-60")}>
                    <CardHeader className="pb-3">
                      <div className="flex items-start justify-between">
                        <div className="flex flex-wrap gap-1">
                          {prompt.moods.map((mood) => (
                            <Badge key={mood} variant="outline" className="text-xs">{mood}</Badge>
                          ))}
                        </div>
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="icon" className="h-8 w-8">
                              <MoreVertical className="h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            <DropdownMenuItem className="gap-2"><Edit className="h-4 w-4" /> Edit</DropdownMenuItem>
                            <DropdownMenuItem className="gap-2 text-destructive"><Trash2 className="h-4 w-4" /> Delete</DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </div>
                    </CardHeader>
                    <CardContent>
                      <p className="text-sm text-foreground mb-3">{prompt.prompt}</p>
                      <div className="flex items-center justify-between">
                        <div className="flex gap-1">
                          {prompt.journalTypes.includes("writing") && (
                            <Badge variant="secondary" className="text-xs gap-1">
                              <PenTool className="h-3 w-3" />
                              Writing
                            </Badge>
                          )}
                          {prompt.journalTypes.includes("art") && (
                            <Badge variant="secondary" className="text-xs gap-1">
                              <Palette className="h-3 w-3" />
                              Art
                            </Badge>
                          )}
                        </div>
                        <div className="flex items-center gap-2">
                          <Power className={cn("h-4 w-4", prompt.isEnabled ? "text-success" : "text-muted-foreground")} />
                          <Switch 
                            checked={prompt.isEnabled} 
                            onCheckedChange={() => handleToggleConfirm("journal", prompt.id, prompt.isEnabled)}
                          />
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </div>
          </TabsContent>

          {/* Music Therapy Tab */}
          <TabsContent value="music" className="space-y-6">
            <div className="relative max-w-md">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <Input 
                placeholder="Search music..."
                className="pl-9"
                value={searchQuery}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredMusicResources.map((resource) => (
                <Card key={resource.id} className={cn("transition-all duration-200 hover:shadow-card-hover", resource.status === "DRAFT" && "opacity-60")}>
                  <CardHeader className="pb-3">
                    <div className="flex items-start justify-between">
                      <div className="flex items-center gap-3">
                        <div className="h-12 w-12 rounded-lg bg-primary/10 flex items-center justify-center">
                          <Music className="h-6 w-6 text-primary" />
                        </div>
                        <div>
                          <CardTitle className="text-base">{resource.title}</CardTitle>
                          <CardDescription className="text-xs">{resource.subtitle || "Music resource"}</CardDescription>
                        </div>
                      </div>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="icon" className="h-8 w-8">
                            <MoreVertical className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem className="gap-2"><Eye className="h-4 w-4" /> Preview</DropdownMenuItem>
                          <DropdownMenuItem className="gap-2"><Edit className="h-4 w-4" /> Edit</DropdownMenuItem>
                          <DropdownMenuItem 
                            className="gap-2 text-destructive" 
                            onClick={() => deleteMusicResource(resource.id)}
                          >
                            <Trash2 className="h-4 w-4" /> Delete
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center gap-2 mb-3">
                      {resource.categories?.map((cat) => (
                        <Badge key={cat.category.name} variant="outline" className="text-xs">{cat.category.name}</Badge>
                      ))}
                      {resource.duration && <span className="text-xs text-muted-foreground">{resource.duration}</span>}
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-muted-foreground">{resource.learnerCount || 0} learners</span>
                      <div className="flex items-center gap-2">
                        <Badge variant={resource.status === "PUBLISHED" ? "default" : "secondary"} className="text-xs">
                          {resource.status.toLowerCase()}
                        </Badge>
                        <Switch 
                          checked={resource.status === "PUBLISHED"} 
                          onCheckedChange={() => handleToggleConfirm("music", resource.id, resource.status === "PUBLISHED")}
                        />
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
              {filteredMusicResources.length === 0 && (
                <div className="col-span-full text-center py-8">
                  <Music className="h-12 w-12 text-muted-foreground mx-auto mb-2" />
                  <p className="text-muted-foreground">No music resources found</p>
                </div>
              )}
            </div>
          </TabsContent>

          {/* Meditation Tab */}
          <TabsContent value="meditation" className="space-y-6">
            <div className="relative max-w-md">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <Input 
                placeholder="Search meditation..."
                className="pl-9"
                value={searchQuery}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredMeditationResources.map((resource) => (
                <Card key={resource.id} className={cn("transition-all duration-200 hover:shadow-card-hover", resource.status === "DRAFT" && "opacity-60")}>
                  <CardHeader className="pb-3">
                    <div className="flex items-start justify-between">
                      <div className="flex items-center gap-3">
                        <div className="h-12 w-12 rounded-lg bg-primary/10 flex items-center justify-center">
                          {resource.format === "video" ? <Play className="h-6 w-6 text-primary" /> : <Sparkles className="h-6 w-6 text-primary" />}
                        </div>
                        <div>
                          <CardTitle className="text-base">{resource.title}</CardTitle>
                          <CardDescription className="text-xs line-clamp-1">{resource.description || "Meditation resource"}</CardDescription>
                        </div>
                      </div>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="icon" className="h-8 w-8">
                            <MoreVertical className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem className="gap-2"><Eye className="h-4 w-4" /> Preview</DropdownMenuItem>
                          <DropdownMenuItem className="gap-2"><Edit className="h-4 w-4" /> Edit</DropdownMenuItem>
                          <DropdownMenuItem 
                            className="gap-2 text-destructive" 
                            onClick={() => deleteMeditationResource(resource.id)}
                          >
                            <Trash2 className="h-4 w-4" /> Delete
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center gap-2 mb-3">
                      {resource.categories?.map((cat) => (
                        <Badge key={cat.category.name} variant="outline" className="text-xs">{cat.category.name}</Badge>
                      ))}
                      <Badge variant="secondary" className="text-xs capitalize">{resource.format}</Badge>
                      {resource.duration && <span className="text-xs text-muted-foreground">{resource.duration}</span>}
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-muted-foreground">{resource.learnerCount || 0} learners</span>
                      <div className="flex items-center gap-2">
                        <Badge variant={resource.status === "PUBLISHED" ? "default" : "secondary"} className="text-xs">
                          {resource.status.toLowerCase()}
                        </Badge>
                        <Switch 
                          checked={resource.status === "PUBLISHED"} 
                          onCheckedChange={() => handleToggleConfirm("meditation", resource.id, resource.status === "PUBLISHED")}
                        />
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
              {filteredMeditationResources.length === 0 && (
                <div className="col-span-full text-center py-8">
                  <Sparkles className="h-12 w-12 text-muted-foreground mx-auto mb-2" />
                  <p className="text-muted-foreground">No meditation resources found</p>
                </div>
              )}
            </div>
          </TabsContent>
        </Tabs>
      </div>

      {/* Add Journal Prompt Dialog */}
      <Dialog open={isAddJournalOpen} onOpenChange={setIsAddJournalOpen}>
        <DialogContent className="sm:max-w-lg">
          <DialogHeader>
            <DialogTitle>Add Journal Prompt</DialogTitle>
            <DialogDescription>Create a new prompt for student journaling. Prompts can be used across writing and art journaling.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label>Prompt</Label>
              <Textarea 
                placeholder="Enter the journal prompt..."
                value={journalForm.prompt}
                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setJournalForm((prev: any) => ({ ...prev, prompt: e.target.value }))}
                rows={3}
              />
            </div>
            <div className="grid gap-2">
              <Label>Journaling Type(s)</Label>
              <div className="flex gap-2">
                {["writing", "art"].map((type) => (
                  <Button
                    key={type}
                    variant={journalForm.journalTypes.includes(type as "writing" | "art") ? "default" : "outline"}
                    size="sm"
                    onClick={() => {
                      if (journalForm.journalTypes.includes(type as "writing" | "art")) {
                        setJournalForm((prev: any) => ({ ...prev, journalTypes: prev.journalTypes.filter((t: string) => t !== type) }));
                      } else {
                        setJournalForm((prev: any) => ({ ...prev, journalTypes: [...prev.journalTypes, type as "writing" | "art"] }));
                      }
                    }}
                  >
                    {type === "writing" ? <PenTool className="h-4 w-4 mr-1" /> : <Palette className="h-4 w-4 mr-1" />}
                    {type.charAt(0).toUpperCase() + type.slice(1)}
                  </Button>
                ))}
              </div>
            </div>
            <div className="grid gap-2">
              <Label>Mood(s)</Label>
              <div className="flex flex-wrap gap-2">
                {journalMoods.map((mood) => (
                  <Button
                    key={mood}
                    variant={journalForm.moods.includes(mood) ? "default" : "outline"}
                    size="sm"
                    onClick={() => {
                      if (journalForm.moods.includes(mood)) {
                        setJournalForm((prev: any) => ({ ...prev, moods: prev.moods.filter((m: string) => m !== mood) }));
                      } else {
                        setJournalForm((prev: any) => ({ ...prev, moods: [...prev.moods, mood] }));
                      }
                    }}
                  >
                    {mood}
                  </Button>
                ))}
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsAddJournalOpen(false)}>Cancel</Button>
            <Button onClick={handleSaveJournal} disabled={isSubmitting}>
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Saving...
                </>
              ) : (
                "Save Prompt"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Add Music Modal */}
      <Dialog open={isAddMusicModalOpen} onOpenChange={setIsAddMusicModalOpen}>
        <DialogContent className="sm:max-w-4xl max-h-[90vh] bg-white overflow-y-auto p-0">
          <DialogHeader className="p-6 border-b border-border">
            <DialogTitle className="text-xl ">Add Music Resource</DialogTitle>
            <DialogDescription className="text-[#65758b] mt-[-6px]">Create a new music therapy resource for learners.</DialogDescription>
          </DialogHeader>
          <div className="grid md:grid-cols-2 gap-0">
            <div className="p-6 border-r border-border space-y-4">
              <div className="space-y-2">
                <Label >Thumbnail</Label>
                <div 
                  className="border-2 mt-[8px] border-dashed border-border rounded-lg p-4 text-center cursor-pointer hover:border-primary/50"
                  onClick={() => document.getElementById('music-thumb')?.click()}
                >
                  {musicForm.thumbnail ? (
                    <img src={musicForm.thumbnail} alt="Thumbnail" className="w-full h-24 object-cover rounded" />
                  ) : (
                    <div className="space-y-1">
                      <Upload className="h-6 w-6 mx-auto text-[#65758b]" />
                      <p className="text-xs text-[#65758b]">Upload thumbnail</p>
                    </div>
                  )}
                  <input id="music-thumb" type="file" accept="image/*" className="hidden" onChange={(e) => handleThumbnailUpload(e, "music")} />
                </div>
              </div>
              <div className="grid gap-2">
                <Label>Title</Label>
                <Input value={musicForm.title} onChange={(e) => setMusicForm(prev => ({ ...prev, title: e.target.value }))} placeholder="Resource title" />
              </div>
              <div className="grid gap-2">
                <Label>Subtitle</Label>
                <Input value={musicForm.subtitle} onChange={(e) => setMusicForm(prev => ({ ...prev, subtitle: e.target.value }))} placeholder="Short subtitle" />
              </div>
              <div className="grid gap-2">
                <Label>Upload Audio</Label>
                <div 
                  className={`relative border-2 border-dashed ${musicForm.audioUrl ? 'border-primary/20 bg-primary/5' : 'border-border rounded-lg'} p-6 text-center cursor-pointer transition-all duration-200 hover:border-primary/50`}
                  onClick={() => document.getElementById('music-audio')?.click()}
                >
                  {musicForm.audioUrl ? (
                    <div className="space-y-2">
                      <audio 
                        src={musicForm.audioUrl} 
                        className="w-full h-16 rounded-md"
                        controls
                      />
                      <div className="flex items-center justify-center text-xs text-[#65758b]">
                        <Music className="h-4 w-4 mr-1" />
                        <span>Audio uploaded successfully</span>
                      </div>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      <Music className="h-8 w-8 mx-auto text-[#65758b]" />
                      <p className="text-xs text-[#65758b] mt-1">Click to upload audio file</p>
                    </div>
                  )}
                  <input 
                    id="music-audio" 
                    type="file" 
                    accept="audio/*" 
                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" 
                    onChange={(e) => handleAudioUpload(e, "music")} 
                  />
                </div>
              </div>
              <p className="text-xs text-muted-foreground">Duration: {musicForm.duration}</p>
              <div className="grid grid-cols-2 gap-4">
                <div className="grid gap-2">
                  <Label>Category</Label>
                  <Select value={musicForm.category} onValueChange={(v) => setMusicForm(prev => ({ ...prev, category: v }))}>
                    <SelectTrigger><SelectValue placeholder="Select" /></SelectTrigger>
                    <SelectContent className="bg-white">
                      {musicCategories.map(c => <SelectItem key={c} value={c} className="hover:bg-[#F8FAFC]">{c} </SelectItem>)}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label>Status</Label>
                  <Select value={musicForm.status} onValueChange={(v: "DRAFT" | "PUBLISHED") => setMusicForm(prev => ({ ...prev, status: v }))}>
                    <SelectTrigger><SelectValue /></SelectTrigger>
                    <SelectContent className="bg-white">
                      <SelectItem value="DRAFT" className="hover:bg-[#F8FAFC]">Draft</SelectItem>
                      <SelectItem value="PUBLISHED"className="hover:bg-[#F8FAFC]">Published</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <div className="grid gap-4">
                <div className="grid gap-2">
                  <Label>Supported Moods</Label>
                  <Popover open={isMusicMoodPopoverOpen} onOpenChange={setIsMusicMoodPopoverOpen}>
                    <PopoverTrigger asChild className="bg-white">
                      <Button variant="outline" role="combobox" className="w-full justify-between h-auto min-h-10">
                        <div className="flex flex-wrap gap-1">
                          {musicForm.supportedMoods && musicForm.supportedMoods.length > 0 ? musicForm.supportedMoods.map((mood) => (
                            <Badge key={mood} variant="secondary" className="text-xs">
                              {mood}
                              <span
                                className="ml-1 hover:text-destructive cursor-pointer"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setMusicForm(prev => ({ ...prev, supportedMoods: prev.supportedMoods?.filter(m => m !== mood) }));
                                }}
                              >
                                <X className="h-3 w-3" />
                              </span>
                            </Badge>
                          )) : <span className="text-muted-foreground">Select moods...</span>}
                        </div>
                        <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-full p-2 border bg-white shadow-xl rounded-[6px]" align="start">
                      <div className="space-y-2">
                        {musicMoods.map((mood) => (
                          <div key={mood} className="flex items-center gap-2 px-2 py-1.5 rounded cursor-pointer hover:bg-muted" onClick={() => {
                            if (musicForm.supportedMoods?.includes(mood)) {
                              setMusicForm(prev => ({ ...prev, supportedMoods: prev.supportedMoods?.filter(m => m !== mood) }));
                            } else {
                              setMusicForm(prev => ({ ...prev, supportedMoods: [...(prev.supportedMoods || []), mood] }));
                            }
                          }}>
                            <div className={`h-4 w-4 border rounded flex items-center justify-center ${musicForm.supportedMoods?.includes(mood) ? 'bg-primary border-primary' : 'border-input'}`}>
                              {musicForm.supportedMoods?.includes(mood) && <Check className="h-3 w-3 text-primary-foreground" />}
                            </div>
                            <span className="text-sm">{mood}</span>
                          </div>
                        ))}
                        <div className="border-t pt-2 mt-2">
                          <div className="flex gap-2">
                            <Input placeholder="Add new mood..." value={newMood} onChange={(e) => setNewMood(e.target.value)} className="h-8 text-sm" onClick={(e) => e.stopPropagation()} />
                            <Button size="sm" className="h-8" onClick={async (e) => { 
                              e.stopPropagation(); 
                              if (newMood.trim() && !musicMoods.includes(newMood.trim())) { 
                                try {
                                  const response = await fetch('/api/admin/music/moods', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ name: newMood.trim(), status: 'ACTIVE' })
                                  });
                                  const result = await response.json();
                                  if (result.success) {
                                    setMusicMoods(prev => [...prev, newMood.trim()]); 
                                    toast({ title: "Music Mood Added" }); 
                                    setNewMood(""); 
                                  } else {
                                    toast({ title: "Error", description: result.error || "Failed to create music mood", variant: "destructive" });
                                  }
                                } catch (error) {
                                  console.error('Error creating music mood:', error);
                                  toast({ title: "Error", description: "Failed to create music mood", variant: "destructive" });
                                }
                              } 
                            }}><Plus className="h-4 w-4" /></Button>
                          </div>
                        </div>
                      </div>
                    </PopoverContent>
                  </Popover>
                </div>
                <div className="grid gap-2">
                  <Label>Goal</Label>
                  <Popover open={isMusicGoalPopoverOpen} onOpenChange={setIsMusicGoalPopoverOpen}>
                    <PopoverTrigger asChild>
                      <Button variant="outline" role="combobox" className="w-full justify-between hover:bg-gray-200">
                        <span className={musicForm.goal ? "" : "text-muted-foreground"}>{musicForm.goal || "Select goal..."}</span>
                        <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-full p-2 border bg-white shadow-xl rounded-[6px]" align="start">
                      <div className="space-y-2">
                        {musicGoals.map((goal) => (
                          <div key={goal} className="flex items-center gap-2 px-2 py-1.5 rounded cursor-pointer hover:bg-muted" onClick={() => { setMusicForm(prev => ({ ...prev, goal })); setIsMusicGoalPopoverOpen(false); }}>
                            <div className={`h-4 w-4 border rounded-full flex items-center justify-center ${musicForm.goal === goal ? 'bg-primary border-primary' : 'border-input'}`}>
                              {musicForm.goal === goal && <div className="h-2 w-2 rounded-full bg-primary-foreground" />}
                            </div>
                            <span className="text-sm">{goal}</span>
                          </div>
                        ))}
                        <div className="border-t pt-2 mt-2">
                          <div className="flex gap-2">
                            <Input placeholder="Add new goal..." value={newGoal} onChange={(e) => setNewGoal(e.target.value)} className="h-8 text-sm" onClick={(e) => e.stopPropagation()} />
                            <Button size="sm" className="h-8" onClick={async (e) => { 
                              e.stopPropagation(); 
                              if (newGoal.trim() && !musicGoals.includes(newGoal.trim())) { 
                                try {
                                  const response = await fetch('/api/labels/goals', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ name: newGoal.trim(), status: 'active' })
                                  });
                                  const result = await response.json();
                                  if (result.success) {
                                    setMusicGoals(prev => [...prev, newGoal.trim()]); 
                                    toast({ title: "Goal Added" }); 
                                    setNewGoal(""); 
                                  } else {
                                    toast({ title: "Error", description: result.error || "Failed to create goal", variant: "destructive" });
                                  }
                                } catch (error) {
                                  console.error('Error creating goal:', error);
                                  toast({ title: "Error", description: "Failed to create goal", variant: "destructive" });
                                }
                              } 
                            }}><Plus className="h-4 w-4" /></Button>
                          </div>
                        </div>
                      </div>
                    </PopoverContent>
                  </Popover>
                </div>
              </div>
            </div>
            <div className="p-6 bg-muted/30">
              <h3 className="text-sm font-medium text-muted-foreground uppercase mb-4">Live Preview</h3>
              <div className="bg-card rounded-xl border border-border overflow-hidden">
                <div className="h-32 bg-gradient-to-br from-[#3B82F6]/20 to-[#3B82F6]/5 flex items-center justify-center">
                  {musicForm.thumbnail ? <img src={musicForm.thumbnail} alt="" className="w-full h-full object-cover" /> : <Music className="h-10 w-10 text-[#3B82F6]/40" />}
                </div>
                <div className="p-4">
                  <h4 className="font-semibold text-foreground">{musicForm.title || "Resource Title"}</h4>
                  <p className="text-sm text-muted-foreground">{musicForm.subtitle || "Subtitle"}</p>
                  <div className="flex items-center gap-2 mt-2">
                    {musicForm.category && <Badge variant="outline" className="text-xs">{musicForm.category}</Badge>}
                    <span className="text-xs text-muted-foreground">{musicForm.duration}</span>
                  </div>
                  <div className="mt-4 flex items-center gap-2 bg-[#334155]/5 rounded-lg p-3">
                    {musicForm.audioUrl && (
                      <audio 
                        src={musicForm.audioUrl} 
                        className="hidden" 
                        onLoadedMetadata={(e) => {
                          const audio = e.target as HTMLAudioElement;
                          const duration = Math.floor(audio.duration);
                          setMusicForm(prev => ({ ...prev, duration: `${duration}s` }));
                        }}
                      />
                    )}
                    <div className="h-8 w-8 rounded-full bg-[#3B82F6] flex items-center justify-center">
                      <button 
                        type="button"
                        onClick={() => {
                          const audio = document.querySelector('audio') as HTMLAudioElement;
                          if (audio) {
                            if (audio.paused) {
                              audio.play();
                            } else {
                              audio.pause();
                            }
                          }
                        }}
                        className="h-8 w-8 rounded-full bg-[#3B82F6] flex items-center justify-center text-white hover:bg-[#2c3e50] transition-colors duration-200"
                      >
                        <Play className="h-4 w-4 text-[#FFFFFF]" />
                      </button>
                    </div>
                    <div className="flex-1 h-1 bg-[#334155] rounded-full">
                      <div className="h-full w-1/3 bg-[#3B82F6] rounded-full" />
                    </div>
                    <span className="text-xs text-muted-foreground">{musicForm.duration}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div className="p-6 border-t border-border flex justify-end gap-2">
            <Button variant="outline" onClick={() => setIsAddMusicModalOpen(false)}>Cancel</Button>
            <Button onClick={handleSaveMusic}>Save</Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Add Category Modal */}
      <Dialog open={isAddCategoryModalOpen} onOpenChange={setIsAddCategoryModalOpen}>
        <DialogContent className="sm:max-w-md bg-white">
          <DialogHeader>
            <DialogTitle>Add Music Category</DialogTitle>
            <DialogDescription className='text-[#65758b]'>
              Create a new category for organizing music resources.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label>Category Name</Label>
              <Input 
                placeholder="e.g., Sleep Sounds" 
                value={categoryForm.name}
                onChange={(e) => setCategoryForm(prev => ({ ...prev, name: e.target.value }))}
              />
            </div>
            <div className="grid gap-2">
              <Label>Status</Label>
              <Select 
                value={categoryForm.status} 
                onValueChange={(value: "ACTIVE" | "INACTIVE") => setCategoryForm(prev => ({ ...prev, status: value }))}
              >
                <SelectTrigger >
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="ACTIVE">Active</SelectItem>
                  <SelectItem value="INACTIVE">Inactive</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsAddCategoryModalOpen(false)}>
              Cancel
            </Button>
            <Button onClick={createMusicCategory} disabled={isSubmitting}>
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Creating...
                </>
              ) : (
                "Create Category"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Add Meditation Modal */}
      <Dialog open={isAddMeditationModalOpen} onOpenChange={setIsAddMeditationModalOpen}>
        <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto bg-white">
          <DialogHeader>
            <DialogTitle>Add Meditation Resource</DialogTitle>
            <DialogDescription className='text-[#65758b]'>
              Create a new meditation resource for students. Fill in the details below.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-6 py-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                <div className="grid gap-2">
                  <Label>Title *</Label>
                  <Input 
                    value={meditationForm.title}
                    onChange={(e) => setMeditationForm(prev => ({ ...prev, title: e.target.value }))}
                    placeholder="Meditation title"
                  />
                </div>
                <div className="grid gap-2">
                  <Label>Description *</Label>
                  <Textarea 
                    value={meditationForm.description}
                    onChange={(e) => setMeditationForm(prev => ({ ...prev, description: e.target.value }))}
                    placeholder="Describe the meditation content"
                    rows={3}
                  />
                </div>
                <div className="grid gap-2">
                  <Label>Instructor</Label>
                  <Input 
                    value={meditationForm.instructor}
                    onChange={(e) => setMeditationForm(prev => ({ ...prev, instructor: e.target.value }))}
                    placeholder="Instructor name"
                  />
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div className="grid gap-2">
                    <Label>Format</Label>
                    <Select value={meditationForm.format} onValueChange={(v: "AUDIO" | "VIDEO" | "TEXT") => setMeditationForm(prev => ({ ...prev, format: v }))}>
                      <SelectTrigger><SelectValue /></SelectTrigger>
                      <SelectContent>
                        <SelectItem value="AUDIO">Audio</SelectItem>
                        <SelectItem value="VIDEO">Video</SelectItem>
                        <SelectItem value="TEXT">Text</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="grid gap-2">
                    <Label>Type</Label>
                    <Select value={meditationForm.type} onValueChange={(v: "GUIDED" | "MUSIC" | "BREATHING" | "BODY_SCAN") => setMeditationForm(prev => ({ ...prev, type: v }))}>
                      <SelectTrigger><SelectValue /></SelectTrigger>
                      <SelectContent>
                        <SelectItem value="GUIDED">Guided</SelectItem>
                        <SelectItem value="MUSIC">Music</SelectItem>
                        <SelectItem value="BREATHING">Breathing</SelectItem>
                        <SelectItem value="BODY_SCAN">Body Scan</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div className="grid gap-2">
                  <Label>Duration (seconds)</Label>
                  <Input 
                    type="number"
                    value={meditationForm.durationSec}
                    onChange={(e) => setMeditationForm(prev => ({ ...prev, durationSec: e.target.value }))}
                    placeholder="Duration in seconds"
                  />
                </div>
              </div>
              
              <div className="space-y-4">
                <div className="grid gap-2">
                  <Label>Thumbnail</Label>
                  <div 
                    className={`relative border-2 border-dashed ${meditationForm.thumbnailUrl ? 'border-primary/20 bg-primary/5' : 'border-border rounded-lg'} p-4 text-center cursor-pointer transition-all duration-200 hover:border-primary/50`}
                    onClick={() => document.getElementById('meditation-thumb')?.click()}
                  >
                    {meditationForm.thumbnailUrl ? (
                      <div className="space-y-2">
                        <img 
                          src={meditationForm.thumbnailUrl} 
                          alt="Thumbnail" 
                          className="w-full h-24 object-cover rounded-md"
                        />
                        <div className="flex items-center justify-center text-xs text-[#65758b]">
                          <Check className="h-4 w-4 mr-1" />
                          <span>Thumbnail uploaded</span>
                        </div>
                      </div>
                    ) : (
                      <div className="space-y-2">
                        <Upload className="h-6 w-6 mx-auto text-[#65758b]" />
                        <p className="text-xs text-[#65758b]">Click to upload thumbnail</p>
                      </div>
                    )}
                    <input id="meditation-thumb" type="file" accept="image/*" className="hidden" onChange={handleMeditationThumbnailUpload} />
                  </div>
                </div>

                {meditationForm.format === "AUDIO" && (
                  <div className="grid gap-2">
                    <Label>Upload Audio</Label>
                    <div 
                      className={`relative border-2 border-dashed ${meditationForm.audioUrl ? 'border-primary/20 bg-primary/5' : 'border-border rounded-lg'} p-4 text-center cursor-pointer transition-all duration-200 hover:border-primary/50`}
                      onClick={() => document.getElementById('meditation-audio')?.click()}
                    >
                      {meditationForm.audioUrl ? (
                        <div className="space-y-2">
                          <audio 
                            src={meditationForm.audioUrl} 
                            className="w-full h-16 rounded-md"
                            controls
                          />
                          <div className="flex items-center justify-center text-xs text-[#65758b]">
                            <Music className="h-4 w-4 mr-1" />
                            <span>Audio uploaded</span>
                          </div>
                        </div>
                      ) : (
                        <div className="space-y-2">
                          <Music className="h-6 w-6 mx-auto text-[#65758b]" />
                          <p className="text-xs text-[#65758b]">Click to upload audio file</p>
                        </div>
                      )}
                      <input 
                        id="meditation-audio" 
                        type="file" 
                        accept="audio/*" 
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" 
                        onChange={handleMeditationAudioUpload} 
                      />
                    </div>
                  </div>
                )}

                {meditationForm.format === "VIDEO" && (
                  <div className="grid gap-2">
                    <Label>Upload Video</Label>
                    <div 
                      className={`relative border-2 border-dashed ${meditationForm.videoUrl ? 'border-primary/20 bg-primary/5' : 'border-border rounded-lg'} p-4 text-center cursor-pointer transition-all duration-200 hover:border-primary/50`}
                      onClick={() => document.getElementById('meditation-video')?.click()}
                    >
                      {meditationForm.videoUrl ? (
                        <div className="space-y-2">
                          <video 
                            src={meditationForm.videoUrl} 
                            className="w-full h-24 rounded-md object-cover"
                          />
                          <div className="flex items-center justify-center text-xs text-[#65758b]">
                            <Play className="h-4 w-4 mr-1" />
                            <span>Video uploaded</span>
                          </div>
                        </div>
                      ) : (
                        <div className="space-y-2">
                          <Play className="h-6 w-6 mx-auto text-[#65758b]" />
                          <p className="text-xs text-[#65758b]">Click to upload video file</p>
                        </div>
                      )}
                      <input 
                        id="meditation-video" 
                        type="file" 
                        accept="video/*" 
                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" 
                        onChange={handleMeditationVideoUpload} 
                      />
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-2 gap-4">
                  <div className="grid gap-2">
                    <Label>Category</Label>
                    <Select value={meditationForm.category} onValueChange={(v) => setMeditationForm(prev => ({ ...prev, category: v }))}>
                      <SelectTrigger><SelectValue placeholder="Select" /></SelectTrigger>
                      <SelectContent>
                        {meditationCategories.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="grid gap-2">
                    <Label>Status</Label>
                    <Select value={meditationForm.status} onValueChange={(v: "DRAFT" | "PUBLISHED") => setMeditationForm(prev => ({ ...prev, status: v }))}>
                      <SelectTrigger><SelectValue /></SelectTrigger>
                      <SelectContent>
                        <SelectItem value="DRAFT">Draft</SelectItem>
                        <SelectItem value="PUBLISHED">Published</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                <div className="grid gap-2">
                  <Label>Goal</Label>
                  <Select value={meditationForm.goal} onValueChange={(v) => setMeditationForm(prev => ({ ...prev, goal: v }))}>
                    <SelectTrigger><SelectValue placeholder="Select goal" /></SelectTrigger>
                    <SelectContent>
                      {meditationGoals.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
                    </SelectContent>
                  </Select>
                </div>

                <div className="grid gap-2">
                  <Label>Mood</Label>
                  <Select value={meditationForm.mood} onValueChange={(v) => setMeditationForm(prev => ({ ...prev, mood: v }))}>
                    <SelectTrigger><SelectValue placeholder="Select mood" /></SelectTrigger>
                    <SelectContent>
                      {meditationMoods.map(m => <SelectItem key={m} value={m}>{m}</SelectItem>)}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsAddMeditationModalOpen(false)}>Cancel</Button>
            <Button onClick={createMeditationResource} disabled={isSubmitting}>
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Creating...
                </>
              ) : (
                "Create Meditation"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Add Meditation Category Modal */}
      <Dialog open={isAddMeditationCategoryModalOpen} onOpenChange={setIsAddMeditationCategoryModalOpen}>
        <DialogContent className="sm:max-w-md bg-white">
          <DialogHeader>
            <DialogTitle>Add Meditation Category</DialogTitle>
            <DialogDescription className='text-[#65758b]'>
              Create a new category for organizing meditation resources.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label>Category Name</Label>
              <Input 
                placeholder="e.g., Mindfulness" 
                value={categoryForm.name}
                onChange={(e) => setCategoryForm(prev => ({ ...prev, name: e.target.value }))}
              />
            </div>
            <div className="grid gap-2">
              <Label>Status</Label>
              <Select 
                value={categoryForm.status} 
                onValueChange={(value: "ACTIVE" | "INACTIVE") => setCategoryForm(prev => ({ ...prev, status: value }))}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="ACTIVE">Active</SelectItem>
                  <SelectItem value="INACTIVE">Inactive</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsAddMeditationCategoryModalOpen(false)}>
              Cancel
            </Button>
            <Button onClick={createMeditationCategory} disabled={isSubmitting}>
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Creating...
                </>
              ) : (
                "Create Category"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Confirm Toggle Dialog */}
      <AlertDialog open={isConfirmOpen} onOpenChange={setIsConfirmOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm {confirmAction?.action === "activate" ? "Activation" : "Deactivation"}</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to {confirmAction?.action} this resource? {confirmAction?.action === "deactivate" && "It will no longer be visible to learners."}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmToggle}>
              {confirmAction?.action === "activate" ? "Activate" : "Deactivate"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
